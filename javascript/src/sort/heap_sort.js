/**
 * ヒープソートを用いて配列を昇順にソートします。
 * （配列自体を変更します - 破壊的メソッド）
 * 
 * ヒープソートは、二分ヒープ（完全二分木）のデータ構造を利用した
 * ソートアルゴリズムです。まず配列を最大ヒープに変換し、
 * ヒープから最大要素を取り出して配列の末尾に配置することを繰り返します。
 * 
 * 二分ヒープの性質:
 * - 完全二分木である
 * - 親ノードは子ノードより大きい（最大ヒープの場合）
 * - 配列のインデックスで表現可能:
 *   - 親: (i-1) / 2
 *   - 左の子: 2*i + 1
 *   - 右の子: 2*i + 2
 * 
 * アルゴリズムの手順:
 * 1. 配列を最大ヒープに変換（heapify）
 * 2. ルート（最大値）を配列の末尾と交換
 * 3. ヒープサイズを1減らし、ヒープを再構築
 * 4. 全要素がソートされるまで2-3を繰り返す
 * 
 * 時間計算量: O(n log n) - 常に同じ
 * 空間計算量: O(1) - 追加のメモリをほとんど使用しない
 * 安定性: 不安定（同じ値の要素の相対的な順序が保持されない場合がある）
 * 
 * @param {Array} array ソート対象の配列
 * @returns {Array} ソートされた配列（元の配列と同じ参照）
 */
function heapSort(array) {
    const n = array.length;

    // ステップ1: 配列を最大ヒープに変換（ヒープの構築）
    // 非リーフノードのみを処理すればよい
    // 最後の非リーフノードのインデックスは Math.floor(n/2) - 1
    // 下から上へ処理することで、効率的にヒープを構築できる
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        _heapify(array, n, i);
    }

    // ステップ2: ヒープから要素を1つずつ取り出してソート
    // 最大要素（ルート）を末尾に移動し、ヒープサイズを縮小
    for (let i = n - 1; i > 0; i--) {
        // ルート（最大値）を現在の末尾と交換
        // これにより、最大値が正しい位置（末尾）に配置される
        [array[0], array[i]] = [array[i], array[0]];

        // 縮小されたヒープを再構築
        // ヒープサイズは i（末尾の要素は除外）
        _heapify(array, i, 0);
    }

    return array;
}

/**
 * ヒープ条件を満たすように部分木を再構築する（ヒープ化）
 * 
 * 指定されたノード i を根とする部分木を最大ヒープに変換します。
 * 子ノードは既にヒープ条件を満たしていることを前提とします。
 * 
 * @param {Array} array 対象の配列
 * @param {number} n ヒープとして扱う範囲（配列の先頭からn要素）
 * @param {number} i ヒープ化の対象となるノードのインデックス
 * @private
 */
function _heapify(array, n, i) {
    // 最大値のインデックス（初期値は現在のノード）
    let largest = i;

    // 左の子のインデックスを計算
    const l = 2 * i + 1;
    // 右の子のインデックスを計算
    const r = 2 * i + 2;

    // 左の子が存在し、かつ親より大きい場合
    if (l < n && array[l] > array[largest]) {
        largest = l;
    }

    // 右の子が存在し、かつ現在の最大値より大きい場合
    if (r < n && array[r] > array[largest]) {
        largest = r;
    }

    // 最大値が親ノードでない場合、交換してヒープ条件を満たす
    if (largest !== i) {
        // 親と最大の子を交換
        [array[i], array[largest]] = [array[largest], array[i]];

        // 交換された子ノードの部分木も再帰的にヒープ化
        // 交換によりヒープ条件が崩れた可能性があるため
        _heapify(array, n, largest);
    }
}

module.exports = { heapSort };
