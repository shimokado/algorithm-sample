"""
エラトステネスのふるいを用いた素数列挙モジュール

このモジュールは、指定された上限値以下の全ての素数を効率的に求める
エラトステネスのふるいアルゴリズムを実装しています。
"""

from typing import List


def sieve_of_eratosthenes(n: int) -> List[int]:
    """
    エラトステネスのふるいを用いて、n以下の素数のリストを返します。
    
    エラトステネスのふるいは、古代ギリシャの数学者エラトステネスが考案した
    素数を見つけるための効率的なアルゴリズムです。
    
    アルゴリズムの手順:
    1. 2からnまでの全ての数を「素数候補」としてマークする
    2. 最小の素数候補（最初は2）を選ぶ
    3. その数の倍数を全て「素数ではない」としてマークする
    4. 次の素数候補を選び、手順3を繰り返す
    5. p * p > n になったら終了
    
    時間計算量: O(n log log n)
    空間計算量: O(n)
    
    Args:
        n (int): 上限値（この値以下の素数を全て求める）
        
    Returns:
        List[int]: n以下の素数を昇順に並べたリスト
    """
    # 2より小さい場合、素数は存在しない
    # 素数の定義: 1より大きく、1とその数自身以外に約数を持たない自然数
    if n < 2:
        return []
    
    # is_prime[i] = True の場合、iは素数の候補
    # 初期状態では全ての数を素数候補（True）とする
    is_prime = [True] * (n + 1)
    
    # 0と1は素数ではないので、Falseに設定
    is_prime[0] = False
    is_prime[1] = False
    
    # pの倍数をふるい落とす処理
    # p * p > n になったら終了（それ以降の倍数は既にふるい落とされている）
    p = 2
    while (p * p <= n):
        # pが素数候補の場合のみ処理を行う
        if is_prime[p]:
            # pの倍数を全て素数ではないとマーク
            # p * p から始める理由: p * 2, p * 3, ... , p * (p-1) は
            # より小さい素数の倍数として既にふるい落とされているため
            # range(p * p, n + 1, p) は p*p から n まで p 刻みで繰り返す
            for i in range(p * p, n + 1, p):
                is_prime[i] = False
        # 次の数へ進む
        p += 1
    
    # 素数のリストを作成
    # is_prime配列でTrueになっている全てのインデックスが素数
    primes = []
    for i in range(2, n + 1):
        if is_prime[i]:
            primes.append(i)
            
    return primes
