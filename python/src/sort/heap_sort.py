"""
ヒープソートモジュール

このモジュールは、二分ヒープのデータ構造を利用した
ヒープソートアルゴリズムを実装しています。
"""

from typing import List, Any


def heap_sort(data: List[Any]) -> List[Any]:
    """
    ヒープソートを用いてリストを昇順にソートします。
    （リスト自体を変更します - 破壊的メソッド）
    
    ヒープソートは、二分ヒープ（完全二分木）のデータ構造を利用した
    ソートアルゴリズムです。まずリストを最大ヒープに変換し、
    ヒープから最大要素を取り出してリストの末尾に配置することを繰り返します。
    
    二分ヒープの性質:
    - 完全二分木である
    - 親ノードは子ノードより大きい（最大ヒープの場合）
    - リストのインデックスで表現可能:
      - 親: (i-1) // 2
      - 左の子: 2*i + 1
      - 右の子: 2*i + 2
    
    アルゴリズムの手順:
    1. リストを最大ヒープに変換（heapify）
    2. ルート（最大値）をリストの末尾と交換
    3. ヒープサイズを1減らし、ヒープを再構築
    4. 全要素がソートされるまで2-3を繰り返す
    
    時間計算量: O(n log n) - 常に同じ
    空間計算量: O(1) - 追加のメモリをほとんど使用しない
    安定性: 不安定（同じ値の要素の相対的な順序が保持されない場合がある）
    
    Args:
        data (List[Any]): ソート対象のリスト
        
    Returns:
        List[Any]: ソートされたリスト（元のリストと同じ参照）
    """
    n = len(data)

    # ステップ1: リストを最大ヒープに変換（ヒープの構築）
    # 非リーフノードのみを処理すればよい
    # 最後の非リーフノードのインデックスは n // 2 - 1
    # 下から上へ処理することで、効率的にヒープを構築できる
    # range(n // 2 - 1, -1, -1) は (n//2-1) から 0 まで逆順に繰り返す
    for i in range(n // 2 - 1, -1, -1):
        _heapify(data, n, i)

    # ステップ2: ヒープから要素を1つずつ取り出してソート
    # 最大要素（ルート）を末尾に移動し、ヒープサイズを縮小
    # range(n - 1, 0, -1) は (n-1) から 1 まで逆順に繰り返す
    for i in range(n - 1, 0, -1):
        # ルート（最大値）を現在の末尾と交換
        # これにより、最大値が正しい位置（末尾）に配置される
        data[i], data[0] = data[0], data[i]
        
        # 縮小されたヒープを再構築
        # ヒープサイズは i（末尾の要素は除外）
        _heapify(data, i, 0)
        
    return data


def _heapify(data: List[Any], n: int, i: int):
    """
    ヒープ条件を満たすように部分木を再構築する（ヒープ化）
    
    指定されたノード i を根とする部分木を最大ヒープに変換します。
    子ノードは既にヒープ条件を満たしていることを前提とします。
    
    Args:
        data (List[Any]): 対象のリスト
        n (int): ヒープとして扱う範囲（リストの先頭からn要素）
        i (int): ヒープ化の対象となるノードのインデックス
    """
    # 最大値のインデックス（初期値は現在のノード）
    largest = i
    
    # 左の子のインデックスを計算
    l = 2 * i + 1
    # 右の子のインデックスを計算
    r = 2 * i + 2

    # 左の子が存在し、かつ親より大きい場合
    if l < n and data[l] > data[largest]:
        largest = l

    # 右の子が存在し、かつ現在の最大値より大きい場合
    if r < n and data[r] > data[largest]:
        largest = r

    # 最大値が親ノードでない場合、交換してヒープ条件を満たす
    if largest != i:
        # 親と最大の子を交換
        data[i], data[largest] = data[largest], data[i]
        
        # 交換された子ノードの部分木も再帰的にヒープ化
        # 交換によりヒープ条件が崩れた可能性があるため
        _heapify(data, n, largest)
